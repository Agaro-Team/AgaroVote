# Redis Cache for Blockchain-Confirmed Poll Creation

## Overview

This document explains the **cache-first, blockchain-confirmed** pattern for poll creation in AgaroVote.

## The Problem

Traditional blockchain applications face a challenge:
1. **Frontend** submits transaction to blockchain
2. **User waits** for blockchain confirmation (15-60 seconds)
3. **Backend** creates database record only after confirmation

This creates poor UX and potential race conditions.

## The Solution: Cache-First Pattern

```
┌──────────┐     ┌──────────┐     ┌────────────┐     ┌───────────────┐     ┌──────────┐
│ Frontend │────▶│  Backend │────▶│   Redis    │────▶│   Blockchain  │────▶│  Event   │
│          │     │   API    │     │   Cache    │     │   Contract    │     │ Listener │
└──────────┘     └──────────┘     └────────────┘     └───────────────┘     └───────────┘
                                         │                     │                    │
                                         │                     │                    │
                                         │                     └────────────────────┤
                                         │                                          │
                                         │                  ┌───────────────────────▼──┐
                                         └──────────────────┤   Activate Poll (DB)     │
                                                            │   /polls/:hash/activate  │
                                                            └──────────────────────────┘
```

## Flow Breakdown

### Step 1: Frontend Stores Data in Cache (Before Blockchain)

**Endpoint**: `POST /api/v1/polls/pending`

```typescript
// Frontend code
const response = await fetch('/api/v1/polls/pending', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    Authorization: `Bearer ${jwt}`,
  },
  body: JSON.stringify(pollData),
});

const { cacheKey, expiresIn } = await response.json();
// { cacheKey: "agaro:pending-poll:0x123...", expiresIn: 1800 }
```

**Backend** (`StorePendingPollUseCase`):
- Validates poll data
- Checks for duplicates in cache
- Stores complete poll data in Redis
- Returns cache key and expiration time
- **Does NOT create database record yet**

### Step 2: Frontend Submits to Blockchain

```typescript
// Frontend submits transaction
const tx = await contract.createPoll({
  title: pollData.title,
  endDate: pollData.endDate,
  // ... other data
});

// Show pending state to user
console.log('Transaction submitted:', tx.hash);

// Optional: Poll for transaction status
await tx.wait(); // Wait for confirmation
```

### Step 3: Blockchain Emits Event

When transaction is confirmed, Solidity contract emits:

```solidity
event PollCreated(
    bytes32 indexed pollHash,
    address indexed creator,
    uint256 timestamp
);
```

### Step 4: Event Listener Captures Event

**Rust Event Listener** (`AGARO-EVENT-LISTENER`):

```rust
// Pseudo-code for event listener
contract.events().filter(move |event| {
    match event {
        PollCreated { poll_hash, creator, .. } => {
            // Call backend API to activate poll
            let url = format!("{}/api/v1/polls/{}/activate", base_url, poll_hash);
            http_client.post(url).send().await?;
        }
    }
});
```

### Step 5: Backend Activates Poll

**Endpoint**: `POST /api/v1/polls/:pollHash/activate`

```typescript
// Event listener calls this
POST /api/v1/polls/0x123.../activate
```

**Backend** (`ActivatePollFromCacheUseCase`):
1. Retrieves poll data from Redis cache using `pollHash`
2. Validates data hasn't expired (30 min TTL)
3. Checks if poll already exists in database (idempotency)
4. Creates poll in PostgreSQL database
5. Creates related choices and addresses
6. **Deletes cache entry** (cleanup)
7. Invalidates related caches (poll lists, user polls)
8. Returns created poll

## Critical Implementation Details

### 1. Cache Key Strategy

```typescript
// Consistent key generation
const cacheKey = `agaro:pending-poll:${pollHash}`;

// Why pollHash?
// - Generated by blockchain (deterministic)
// - Unique per poll
// - Same hash used by event listener
// - Prevents duplicates
```

### 2. TTL (Time To Live)

```typescript
const PENDING_POLL_TTL = 1800; // 30 minutes

// Why 30 minutes?
// - Blockchain confirmation: ~15-60 seconds
// - Network delays: +5 minutes buffer
// - User abandonment: Auto-cleanup after 30 min
// - Prevents stale data accumulation
```

### 3. Idempotency Protection

```typescript
// Check if poll already exists
const existingPoll = await pollRepository.findByPollHash(pollHash);
if (existingPoll) {
  await cacheService.del(cacheKey); // Cleanup
  throw new ConflictException('Poll already activated');
}
```

**Why this matters**:
- Event listener might retry on failure
- Prevents duplicate database records
- Ensures data consistency

### 4. Error Handling

```typescript
if (!pendingPollData) {
  throw new NotFoundException(
    `No pending poll data found. Cache may have expired.`
  );
}
```

**Possible scenarios**:
- Cache expired (>30 min since submission)
- Poll was already activated
- Cache was manually cleared
- Redis connection issue

### 5. Cleanup Strategy

```typescript
// After successful creation
await cacheService.del(cacheKey);

// Also invalidate related caches
await cacheService.delMany([
  'polls:list',
  `user:${creatorAddress}:polls`,
]);
```

## Advantages of This Pattern

### ✅ 1. Better User Experience
- Immediate feedback ("Poll submitted!")
- No waiting for blockchain confirmation
- User can navigate away

### ✅ 2. Data Integrity
- Only creates poll AFTER blockchain confirms
- Prevents orphaned database records
- Source of truth is blockchain

### ✅ 3. Idempotency
- Multiple event listener retries won't create duplicates
- Safe to replay events

### ✅ 4. Scalability
- Redis handles temporary data (not PostgreSQL)
- Automatic cleanup via TTL
- No manual garbage collection needed

### ✅ 5. Auditability
```typescript
const pendingPollData = {
  ...createPollDto,
  submittedAt: new Date().toISOString(), // Track submission time
  status: 'pending_blockchain_confirmation',
};
```

## Potential Issues & Solutions

### ⚠️ Issue 1: Cache Expires Before Blockchain Confirms

**Scenario**: Blockchain is slow (>30 min)

**Solution**:
```typescript
// Increase TTL for mainnet
const PENDING_POLL_TTL = process.env.NODE_ENV === 'production' 
  ? 3600  // 1 hour for mainnet
  : 1800; // 30 min for testnet
```

### ⚠️ Issue 2: Event Listener Misses Event

**Scenario**: Event listener is down during emit

**Solution**:
```rust
// Event listener with checkpoint/recovery
let last_block = load_checkpoint();
contract.events()
  .from_block(last_block)  // Replay missed events
  .stream()
```

### ⚠️ Issue 3: Redis is Down

**Scenario**: Redis unavailable when storing pending poll

**Solution**:
```typescript
// Fallback to synchronous flow
try {
  await cacheService.set(cacheKey, data, TTL);
} catch (error) {
  logger.error('Redis unavailable, using fallback');
  // Option 1: Return error to frontend
  throw new ServiceUnavailableException('Cache unavailable');
  
  // Option 2: Store in database with 'pending' status
  await pollRepository.createPending(data);
}
```

### ⚠️ Issue 4: Blockchain Reverts Transaction

**Scenario**: Transaction fails after frontend stores in cache

**Solution**:
```typescript
// Frontend checks transaction status
const receipt = await tx.wait();
if (receipt.status === 0) {
  // Transaction reverted, notify backend to cleanup
  await fetch(`/api/v1/polls/pending/${pollHash}`, {
    method: 'DELETE'
  });
}
```

Backend endpoint:
```typescript
@Delete('pending/:pollHash')
async deletePendingPoll(@Param('pollHash') pollHash: string) {
  const cacheKey = this.cacheService.generateKey('pending-poll', pollHash);
  await this.cacheService.del(cacheKey);
  return { success: true };
}
```

## Alternative Patterns Considered

### ❌ Pattern 1: Database with 'Pending' Status

```typescript
// Create poll immediately with pending status
await pollRepository.create({
  ...pollData,
  status: 'pending',
  isActive: false,
});

// Event listener updates status
await pollRepository.update(pollHash, {
  status: 'confirmed',
  isActive: true,
});
```

**Why NOT this?**:
- Pollutes database with unconfirmed records
- Need manual cleanup of abandoned polls
- More complex status management
- Slower database writes

### ❌ Pattern 2: Frontend Waits for Confirmation

```typescript
// Frontend waits
const tx = await contract.createPoll(data);
await tx.wait(); // Blocks for 15-60 seconds

// Then create in backend
await fetch('/api/v1/polls', { method: 'POST', body: data });
```

**Why NOT this?**:
- Poor UX (user waits)
- User might close browser tab
- Connection timeouts
- Doesn't scale

### ✅ Pattern 3: Cache-First (Current Approach)

**Why YES**:
- Best of both worlds
- Fast UX + Data integrity
- Automatic cleanup
- Scalable

## Testing Strategy

### Unit Tests

```typescript
describe('StorePendingPollUseCase', () => {
  it('should store poll data in cache', async () => {
    const result = await useCase.execute(mockDto, walletAddress);
    expect(result.cacheKey).toContain('pending-poll');
    expect(result.expiresIn).toBe(1800);
  });

  it('should throw if pollHash already pending', async () => {
    await useCase.execute(mockDto, walletAddress);
    await expect(
      useCase.execute(mockDto, walletAddress)
    ).rejects.toThrow(ConflictException);
  });
});

describe('ActivatePollFromCacheUseCase', () => {
  it('should create poll from cache data', async () => {
    // Setup cache
    await cacheService.set(cacheKey, mockData, 1800);
    
    const poll = await useCase.execute(pollHash);
    expect(poll.pollHash).toBe(pollHash);
    expect(poll.isActive).toBe(true);
  });

  it('should throw if cache expired', async () => {
    await expect(
      useCase.execute(nonExistentPollHash)
    ).rejects.toThrow(NotFoundException);
  });

  it('should be idempotent', async () => {
    await useCase.execute(pollHash);
    
    // Second call should throw conflict
    await expect(
      useCase.execute(pollHash)
    ).rejects.toThrow(ConflictException);
  });
});
```

### Integration Tests

```typescript
describe('Poll Creation Flow E2E', () => {
  it('should complete full blockchain-confirmed flow', async () => {
    // 1. Store pending
    const pending = await request(app)
      .post('/api/v1/polls/pending')
      .send(pollData);
    
    // 2. Simulate blockchain event
    const activated = await request(app)
      .post(`/api/v1/polls/${pollHash}/activate`);
    
    expect(activated.body.isActive).toBe(true);
    
    // 3. Verify cache cleaned up
    const cache = await cacheService.get(pending.body.cacheKey);
    expect(cache).toBeUndefined();
  });
});
```

## Monitoring & Observability

### Metrics to Track

```typescript
// Cache hit rate
const cacheHitRate = successfulActivations / totalActivationAttempts;

// Cache expiration rate
const expirationRate = expiredCaches / totalPendingPolls;

// Activation latency
const activationLatency = activatedAt - submittedAt;

// Event listener lag
const eventListenerLag = eventProcessedAt - eventEmittedAt;
```

### Logging

```typescript
logger.info('Pending poll stored', {
  pollHash,
  cacheKey,
  walletAddress,
  expiresAt: new Date(Date.now() + TTL * 1000),
});

logger.info('Poll activated from cache', {
  pollHash,
  pollId: poll.id,
  latency: Date.now() - pendingPollData.submittedAt,
});

logger.warn('Cache expired before activation', {
  pollHash,
  ageInSeconds: (Date.now() - submission) / 1000,
});
```

## Security Considerations

### 1. Validate Wallet Address

```typescript
// Only allow poll creator to activate
if (pendingPollData.creatorAddress !== authenticatedWallet) {
  throw new ForbiddenException('Not poll creator');
}
```

### 2. Rate Limiting

```typescript
// Prevent cache flooding
@Throttle(10, 60) // 10 requests per minute
@Post('polls/pending')
async storePending() { ... }
```

### 3. Input Sanitization

```typescript
// Validate all fields before caching
const schema = Joi.object({
  title: Joi.string().max(200).required(),
  description: Joi.string().max(5000),
  pollHash: Joi.string().regex(/^0x[a-fA-F0-9]{64}$/),
});
```

### 4. Event Listener Authentication

```typescript
// Event listener should authenticate
@Post('polls/:pollHash/activate')
@UseGuards(EventListenerGuard)
async activate() { ... }

// Guard checks API key from event listener
@Injectable()
export class EventListenerGuard {
  canActivate(context: ExecutionContext) {
    const apiKey = context.switchToHttp().getRequest().headers['x-api-key'];
    return apiKey === process.env.EVENT_LISTENER_API_KEY;
  }
}
```

## Deployment Checklist

- [ ] Redis configured with persistence
- [ ] TTL set appropriately for network (testnet vs mainnet)
- [ ] Event listener API key configured
- [ ] Monitoring dashboards set up
- [ ] Cache expiration alerts configured
- [ ] Rate limiting enabled
- [ ] Integration tests passing
- [ ] Load testing completed
- [ ] Rollback plan documented

## Conclusion

The **cache-first, blockchain-confirmed** pattern provides:
- ✅ Excellent UX (immediate feedback)
- ✅ Data integrity (blockchain as source of truth)
- ✅ Scalability (Redis handles temporary data)
- ✅ Reliability (idempotent operations)
- ✅ Maintainability (automatic cleanup via TTL)

This is the **recommended approach** for blockchain-confirmed operations in AgaroVote.

---

**Related Files**:
- Use Cases: `create-poll-with-cache.use-case.ts`
- Event Listener: `AGARO-EVENT-LISTENER/src/main.rs`
- Cache Module: `src/shared/infrastructure/cache/`

**Last Updated**: October 23, 2025
